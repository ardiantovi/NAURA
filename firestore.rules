/**
 * @fileoverview Firestore Security Rules for TechSphere Admin Panel
 *
 * Core Philosophy:
 * This ruleset enforces a strict admin-only access model for managing products and banners.
 * Only authenticated users with a corresponding document in the `/roles_admin` collection
 * are granted read and write access. This ensures that only authorized personnel can
 * modify product listings or banner configurations.
 *
 * Data Structure:
 * The data is organized into two top-level collections: `/products` and `/banners`.
 * - `/products/{productId}` stores information about individual products.
 * - `/banners/{bannerId}` stores information about website banners.
 * Administrative roles are managed in the `/roles_admin/{userId}` collection. The existence
 * of a document in this collection indicates that the user is an administrator.
 *
 * Key Security Decisions:
 * - **Admin-Only Access:** All data modification operations are restricted to administrators.
 * - **No Public Access:** No public write access is granted to any collection.
 * - **Existence-Based Roles:** Admin privileges are determined by the presence of a document
 *   with the user's ID in the `/roles_admin` collection. This approach simplifies rule logic
 *   and avoids the need to store role data within the document itself.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     * @return {bool} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the user is an admin by verifying the existence of a document in the /roles_admin collection.
     * @return {bool} True if the user is an admin, false otherwise.
     */
    function isAdmin() {
      return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * @description Security rules for the /products collection.
     * @path /products/{productId}
     * @allow write: An admin user can create, update, and delete product documents.
     * @deny write: A non-admin user cannot create, update, or delete product documents.
     * @allow read: Any user (authenticated or not) can read product documents.
     * @principle Enforces admin-only write access for product management, while allowing public read access for the storefront.
     */
    match /products/{productId} {
      allow read: if true;
      allow write: if isSignedIn() && isAdmin();
    }

    /**
     * @description Security rules for the /banners collection.
     * @path /banners/{bannerId}
     * @allow write: An admin user can create, update, and delete banner documents.
     * @deny write: A non-admin user cannot create, update, or delete banner documents.
     * @allow read: Any user (authenticated or not) can read banner documents.
     * @principle Enforces admin-only write access for banner management, while allowing public read access for the storefront.
     */
    match /banners/{bannerId} {
      allow read: if true;
      allow write: if isSignedIn() && isAdmin();
    }

    /**
     * @description Security rules for the /roles_admin collection.
     * @path /roles_admin/{userId}
     * @allow create: A user can create their own admin role document. This is key for the first admin setup.
     * @allow read, update, delete, list: Only existing admins can manage other admin roles.
     * @principle Allows for initial self-promotion to admin, then restricts further role management to admins only.
     */
    match /roles_admin/{userId} {
        allow get: if isSignedIn() && isAdmin();
        allow list: if isSignedIn() && isAdmin();
        // A user can create their OWN admin document. This is the fix.
        allow create: if isSignedIn() && request.auth.uid == userId;
        allow update: if isSignedIn() && isAdmin();
        allow delete: if isSignedIn() && isAdmin();
    }
  }
}
